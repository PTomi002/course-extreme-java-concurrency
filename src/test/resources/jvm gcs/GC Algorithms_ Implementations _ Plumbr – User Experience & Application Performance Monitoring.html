<!DOCTYPE html>
<!-- saved from url=(0072)https://plumbr.io/handbook/garbage-collection-algorithms-implementations -->
<html lang="en"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<meta http-equiv="X-UA-Compatible" content="IE=edge">

		<link rel="shortcut icon" href="https://plumbr.io/app/themes/plumbr/dist/images/favicon_9b72e733.png">

	<title>GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring</title>

<!-- The SEO Framework by Sybre Waaijer -->
<meta name="description" content="Now that we have reviewed the core concepts behind GC algorithms, let us move to the specific implementations one can find inside the JVM.">
<meta property="og:image" content="https://plumbr.io/app/uploads/2015/10/plumbr-980.png">
<meta property="og:image:width" content="980">
<meta property="og:image:height" content="370">
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring">
<meta property="og:description" content="Now that we have reviewed the core concepts behind GC algorithms, let us move to the specific implementations one can find inside the JVM. An important aspect to recognize first is the fact that…">
<meta property="og:url" content="https://plumbr.io/handbook/garbage-collection-algorithms-implementations">
<meta property="og:site_name" content="Plumbr – User Experience &amp; Application Performance Monitoring">
<meta property="article:publisher" content="https://www.facebook.com/javaplumbr">
<meta property="article:published_time" content="2015-06-02T11:22+00:00">
<meta property="article:modified_time" content="2019-02-05T11:53-01:00">
<meta property="og:updated_time" content="2019-02-05T11:53-01:00">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@JavaPlumbr">
<meta name="twitter:title" content="GC Algorithms: Implementations | Plumbr – User Experience &amp; Application Performance Monitoring">
<meta name="twitter:description" content="Now that we have reviewed the core concepts behind GC algorithms, let us move to the specific implementations one can find inside the JVM. An important aspect to recognize first is the fact that…">
<meta name="twitter:image" content="https://plumbr.io/app/uploads/2015/10/plumbr-980.png">
<meta name="twitter:image:width" content="980">
<meta name="twitter:image:height" content="370">
<link rel="canonical" href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations">
<script src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/collectedforms.js.download" type="text/javascript" id="CollectedForms-5894543" crossorigin="anonymous" data-leadin-portal-id="5894543" data-leadin-env="prod" data-loader="hs-scriptloader" data-hsjs-portal="5894543" data-hsjs-env="prod" data-hsjs-hublet="na1"></script><script src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/5894543.js.download" type="text/javascript" id="hs-analytics"></script><script src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/5894543.js(1).download" type="text/javascript" id="cookieBanner-5894543" data-cookieconsent="ignore" data-loader="hs-scriptloader" data-hsjs-portal="5894543" data-hsjs-env="prod" data-hsjs-hublet="na1"></script><script async="" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/analytics.js.download"></script><script type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://plumbr.io/","name":"Plumbr &#8211; User Experience &amp; Application Performance Monitoring"}},{"@type":"ListItem","position":2,"item":{"@id":"https://plumbr.io/handbook/java-garbage-collection-handbook","name":"Java Garbage Collection handbook"}},{"@type":"ListItem","position":3,"item":{"@id":"https://plumbr.io/handbook/garbage-collection-algorithms-implementations","name":"GC Algorithms: Implementations"}}]}</script>
<!-- / The SEO Framework by Sybre Waaijer | 4.38ms meta | 0.38ms boot -->

<link rel="dns-prefetch" href="https://js.hs-scripts.com/">
<link rel="dns-prefetch" href="https://use.typekit.net/">
<link rel="stylesheet" id="wp-block-library-css" href="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/style.min.css" type="text/css" media="all">
<link rel="stylesheet" id="plumbr/main.css-css" href="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/main_113b80ea.css" type="text/css" media="all">
<link rel="stylesheet" id="plumbr/typekit.css-css" href="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/thh1ylu.css" type="text/css" media="all">

<link rel="https://api.w.org/" href="https://plumbr.io/wp-json/">
<link rel="alternate" type="application/json+oembed" href="https://plumbr.io/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fplumbr.io%2Fhandbook%2Fgarbage-collection-algorithms-implementations">
<link rel="alternate" type="text/xml+oembed" href="https://plumbr.io/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fplumbr.io%2Fhandbook%2Fgarbage-collection-algorithms-implementations&amp;format=xml">
			<!-- DO NOT COPY THIS SNIPPET! Start of Page Analytics Tracking for HubSpot WordPress plugin v7.48.24-->
			<script type="text/javascript">
				var _hsq = _hsq || [];
				_hsq.push(["setContentType", "blog-post"]);
			</script>
			<!-- DO NOT COPY THIS SNIPPET! End of Page Analytics Tracking for HubSpot WordPress plugin -->
						<script>
				(function() {
					var hbspt = window.hbspt = window.hbspt || {};
					hbspt.forms = hbspt.forms || {};
					hbspt._wpFormsQueue = [];
					hbspt.enqueueForm = function(formDef) {
						if (hbspt.forms && hbspt.forms.create) {
							hbspt.forms.create(formDef);
						} else {
							hbspt._wpFormsQueue.push(formDef);
						}
					}
					if (!window.hbspt.forms.create) {
						Object.defineProperty(window.hbspt.forms, 'create', {
							configurable: true,
							get: function() {
								return hbspt._wpCreateForm;
							},
							set: function(value) {
								hbspt._wpCreateForm = value;
								while (hbspt._wpFormsQueue.length) {
									var formDef = hbspt._wpFormsQueue.shift();
									if (!document.currentScript) {
										var formScriptId = 'leadin-forms-v2-js';
										hubspot.utils.currentScript = document.getElementById(formScriptId);
									}
									hbspt._wpCreateForm.call(hbspt.forms, formDef);
								}
							},
						});
					}
				})();
			</script>
		<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
			<link rel="stylesheet" href="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/prettify.css">
	
	    <script>
        (function () {
            var RDECODE = /(%[0-9A-Z]{2})+/g;

            function plumbrGetCookie(e) {
                var o = document.cookie ? document.cookie.split("; ") : [];
                for (var c = 0; c < o.length; c++) {
                    var n = o[c].indexOf("=");
                    if (e === o[c].slice(0, n).replace(RDECODE, decodeURIComponent)) {
                        return o[c].slice(n + 1).replace(RDECODE, decodeURIComponent)
                    }
                }
            }
            try {
                var plumbrConsentCookie = plumbrGetCookie('plumbrCookieConsent')
                if (plumbrConsentCookie) {
                    window.plumbrConsent = JSON.parse(plumbrConsentCookie);
                }
            } catch (e) {
                console.error('Cookie error')
            }
        })()
    </script>
	<script src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/pa-early.js.download" crossorigin="anonymous" data-plumbr-lateinit=""></script>
	<script>
		var paConf = {
            "accountId": "k8g0ta8m6e7gsb2afhq6qm5efh",
            "serverUrl": "https://plumbr.plumbr.io",
            "appName": "plumbr.io"
		}

		if (!window.plumbrConsent || !window.plumbrConsent.analytics) {
            paConf["tracking"] = {
                "user": false,
                "session": false
            };
        }

        PLUMBR.init(paConf);
	</script>

    
    <script>
		if (!window.plumbrConsentCookie || !window.plumbrConsentCookie.analytics) {
            window['ga-disable-UA-25569981-1'] = true;
		}

        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-25569981-1', 'auto');
        ga('require', 'displayfeatures');
        ga('require', 'eventTracker');
        ga('require', 'outboundLinkTracker');
        ga('send', 'pageview');
    </script>

	<script type="application/ld+json">
	{
		"@context" : "http://schema.org",
		"@type"    : "Organization",
		"name"     : "Plumbr &#8211; User Experience &amp; Application Performance Monitoring",
		"url" 	   : "https://plumbr.io",
		"sameAs"   : [
			"https://www.facebook.com/javaplumbr",
            "https://twitter.com/JavaPlumbr",
            "https://www.linkedin.com/company/plumbr"
		]
	}
</script></head>

<body class=" ">
<div class="top-banner">
	Splunk Completes Acquisition of Plumbr <a href="https://www.splunk.com/en_us/blog/conf-splunklive/splunk-extends-best-in-class-observability-suite.html">Learn more <i class="icon icon-right-open"></i></a>
</div>
<div id="header" class="clear">
	<div class="wrap clear">
		<p id="logo"><a href="https://plumbr.io/" class="icon icon-plumbr"></a></p>

		<div id="user-box">
			<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" data-modal="modal-login" class="js-show-logged-out">Log In</a>
			<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" class="btn cta" id="menu-toggler"><i class="icon icon-menu"></i></a>

			<a id="continueMonitoring" href="https://app.plumbr.io/" class="btn cta btn-icon hidden js-show-logged-in"><i class="icon icon-chart-area hidden"></i> Continue Monitoring</a>
		</div>

					<ul id="nav" class="menu"><li class="parent"><a href="https://plumbr.io/product">Product</a><div class="submenu" style="display: none;"><ul><li><a href="https://plumbr.io/product/features">Features</a></li><li><a href="https://plumbr.io/product/apm">APM</a></li><li><a href="https://plumbr.io/product/rum">RUM</a></li><li><a href="https://plumbr.io/integrations">Integrations</a></li></ul></div></li><li class="parent"><a href="https://plumbr.io/solutions">Solutions</a><div class="submenu" style="display: none;"><ul><li><a href="https://plumbr.io/solutions/devops">Devops</a></li><li><a href="https://plumbr.io/solutions/oncall-engineers">On-call Engineers</a></li></ul></div></li><li><a href="https://plumbr.io/pricing">Pricing</a></li><li class="parent"><a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#">Resources</a><div class="submenu" style="display: none;"><ul><li><a href="https://plumbr.io/how-plumbr-works">How Plumbr Works</a></li><li><a href="https://plumbr.io/blog">Blog</a></li><li><a href="https://plumbr.io/case-study/port-of-tallinn">Case studies</a></li><li><a href="https://plumbr.io/support">Support</a></li><li><a href="https://plumbr.io/root-causes">Root Causes</a></li></ul></div></li></ul>			</div>
</div>



<div id="user-nav">
    <div class="wrap clear">
        <ul>
                <li class="">
        <a href="https://plumbr.io/outofmemoryerror">
            <i class="icon icon-book"></i>
			java.lang.Outofmemoryerror        </a>
    </li>
    <li class="active">
        <a href="https://plumbr.io/java-garbage-collection-handbook">
            <i class="icon icon-book"></i>
			Java Garbage Collection handbook        </a>
    </li>
	        </ul>
    </div>
</div>
<div id="content">
    <div class="wrap split">

        <p id="sidebar-toggler">
            <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" data-label="Close categories">
                <i class="icon icon-menu"></i>
                <i class="icon icon-cancel"></i>
                <span class="label">Handbook menu</span>
            </a>
        </p>

        <div id="sidebar">

			    <div class="floating-wrap" style="padding-top: 0px;">
        <div class="floating-content" style="position: static; top: auto; left: 0px; bottom: auto; width: 226px; margin-bottom: 0px;">
			
							
                <div class="box menu ">
                    <h2>
                        <a href="https://plumbr.io/handbook/what-is-garbage-collection">
							What Is Garbage Collection?                        </a>
						                            <a href="https://plumbr.io/handbook/what-is-garbage-collection" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/what-is-garbage-collection#manual-memory-management">
						Manual Memory Management                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/what-is-garbage-collection#on-demand">
						Smart Pointers                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/what-is-garbage-collection#automated-memory-management">
						Automated Memory Management                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/what-is-garbage-collection#reference-counting">
						Reference Counting                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/what-is-garbage-collection#mark-and-sweep">
						Mark and Sweep                    </a>
							                </li>
			        </ul>
		                </li>
			        </ul>
		                </div>
							
                <div class="box menu ">
                    <h2>
                        <a href="https://plumbr.io/handbook/garbage-collection-in-java">
							Garbage Collection in Java                        </a>
						                            <a href="https://plumbr.io/handbook/garbage-collection-in-java" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#fragmenting-and-compacting">
						Fragmenting and Compacting                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#generational-hypothesis">
						Generational Hypothesis                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#memory-pools">
						Memory Pools                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#eden">
						Eden                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#survivor-spaces">
						Survivor Spaces                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#oldtenured-space">
						Old Generation                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#permgen">
						PermGen                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#metaspace">
						Metaspace                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#minor-gc-major-gc-full-gc">
						Minor GC vs Major GC vs Full GC                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#minor-gc">
						Minor GC                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-in-java#major-gc-vs-full-gc">
						Major GC vs Full GC                    </a>
							                </li>
			        </ul>
		                </li>
			        </ul>
		                </div>
							
                <div class="box menu ">
                    <h2>
                        <a href="https://plumbr.io/handbook/garbage-collection-algorithms">
							GC Algorithms: Basics                        </a>
						                            <a href="https://plumbr.io/handbook/garbage-collection-algorithms" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms#marking-reachable-objects">
						Marking Reachable Objects                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms#removing-unused-objects">
						Removing Unused Objects                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms#sweep">
						Sweep                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms#compact">
						Compact                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms#copy">
						Copy                    </a>
							                </li>
			        </ul>
		                </li>
			        </ul>
		                </div>
							
                <div class="box menu active open">
                    <h2>
                        <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations">
							GC Algorithms: Implementations                        </a>
						                            <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#serial-gc">
						Serial GC                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#serial-minor-gc">
						Minor GC                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#serial-full-gc">
						Full GC                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#parallel-gc">
						Parallel GC                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#parallel-minor-gc">
						Minor GC                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#parallel-full-gc">
						Full GC                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep">
						Concurrent Mark and Sweep                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#cms-minor-gc">
						Minor GC                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#cms-full-gc">
						Full GC                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#g1">
						G1 – Garbage First                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#evacuation-pause-fully-young">
						Evacuation Pause: Fully Young                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#concurrent-marking">
						Concurrent Marking                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#evacuation-pause-mixed">
						Evacuation Pause: Mixed                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#summary">
						Summary                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#shenandoah">
						Shenandoah                    </a>
							                </li>
			        </ul>
		                </div>
							
                <div class="box menu ">
                    <h2>
                        <a href="https://plumbr.io/handbook/gc-tuning">
							GC Tuning: Basics                        </a>
						                            <a href="https://plumbr.io/handbook/gc-tuning" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#throughput-vs-latency-vs-capacity">
						Core Concepts                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#latency">
						Latency                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#throughput">
						Throughput                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#capacity">
						Capacity                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#example">
						Example                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#tuning-for-latency">
						Tuning for Latency                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#tuning-for-throughput">
						Tuning for Throughput                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning#tuning-for-capacity">
						Tuning for Capacity                    </a>
							                </li>
			        </ul>
		                </li>
			        </ul>
		                </div>
							
                <div class="box menu ">
                    <h2>
                        <a href="https://plumbr.io/handbook/gc-tuning-measuring">
							GC Tuning: Tooling                        </a>
						                            <a href="https://plumbr.io/handbook/gc-tuning-measuring" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#jmx-api">
						JMX API                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#jvisualvm">
						JVisualVM                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#jstat">
						jstat                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#gc-logs">
						GC logs                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#gcviewer">
						GCViewer                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#profilers">
						Profilers                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#hprof">
						hprof                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#java-visualvm">
						Java VisualVM                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-measuring#aprof">
						AProf                    </a>
							                </li>
			        </ul>
		                </li>
			        </ul>
		                </div>
							
                <div class="box menu ">
                    <h2>
                        <a href="https://plumbr.io/handbook/gc-tuning-in-practice">
							GC Tuning: In Practice                        </a>
						                            <a href="https://plumbr.io/handbook/gc-tuning-in-practice" class="expander"><i class="icon icon-down-open"></i><i class="icon icon-up-open"></i></a>
						                    </h2>
								        <ul class=" support-menu">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#high-allocation-rate">
						High Allocation Rate                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#how-to-measure-allocation-rate">
						How to Measure Allocation Rate?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#why-should-i-care">
						Why Should I Care?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#give-me-an-example">
						Give me an Example                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#could-my-jvms-be-affected">
						Could my JVMs be Affected?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#what-is-the-solution">
						What is the Solution?                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#premature-promotion">
						Premature Promotion                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#how-to-measure-promotion-rate">
						How to Measure Promotion Rate                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#why-should-i-care-promotion">
						Why Should I Care?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#give-me-an-example-promotion">
						Give me an Example                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#could-my-jvms-be-affected-promotion">
						Could my JVMs be Affected?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#what-is-the-solution-promotion">
						What is the Solution?                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#weak-soft-and-phantom-references">
						Weak, Soft and Phantom References                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#why-should-i-care-references">
						Why Should I Care?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#give-me-an-example-references">
						Give me an Example                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#could-my-jvms-be-affected-references">
						Could my JVMs be Affected?                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#what-is-the-solution-references">
						What is the Solution?                    </a>
							                </li>
			        </ul>
		                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#other-examples">
						Other Examples                    </a>
								        <ul class="">
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#rmi-gc">
						RMI &amp; GC                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#jvmti-tagging-gc">
						JVMTI tagging &amp; GC                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#humongous-allocations">
						Humongous Allocations                    </a>
							                </li>
			                <li>
                    <a href="https://plumbr.io/handbook/gc-tuning-in-practice#conclusion">
						Conclusion                    </a>
							                </li>
			        </ul>
		                </li>
			        </ul>
		                </div>
			        </div>
    </div>
	
        </div>
        <div id="main">
            <div class="article handbook">
									
<h1 class="highlight">GC Algorithms: Implementations</h1>
<p>Now that we have reviewed the core concepts behind GC algorithms, let us move to the specific implementations one can find inside the JVM. An important aspect to recognize first is the fact that, for most JVMs out there, two different GC algorithms are needed – one to clean the Young Generation and another to clean&nbsp;the Old Generation.</p>
<p>You can choose from a variety of such algorithms bundled into the JVM. If you do not specify a garbage collection algorithm explicitly, a platform-specific default will be used. In this chapter, the working principles of each of those algorithms will be&nbsp;explained.</p>
<p>For a quick cheat sheet, the following list is a fast way to get yourself up to speed with which algorithm combinations are possible. Note that this stands true for Java 8, for older Java versions the available combinations might differ a bit:</p>
<table class="data compact">
<thead>
<tr>
<th><b>Young</b></th>
<th><b>Tenured</b></th>
<th><b>JVM options</b></th>
</tr>
</thead>
<tbody>
<tr>
<td>Incremental</td>
<td>Incremental</td>
<td>-Xincgc</td>
</tr>
<tr>
<td><b>Serial</b></td>
<td><b>Serial</b></td>
<td><b>-XX:+UseSerialGC</b></td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Serial</td>
<td>-XX:+UseParallelGC -XX:-UseParallelOldGC</td>
</tr>
<tr>
<td>Parallel New</td>
<td>Serial</td>
<td>N/A</td>
</tr>
<tr>
<td>Serial</td>
<td>Parallel Old</td>
<td>N/A</td>
</tr>
<tr>
<td><b>Parallel Scavenge</b></td>
<td><b>Parallel Old</b></td>
<td><b>-XX:+UseParallelGC -XX:+UseParallelOldGC</b></td>
</tr>
<tr>
<td>Parallel New</td>
<td>Parallel Old</td>
<td>N/A</td>
</tr>
<tr>
<td>Serial</td>
<td>CMS</td>
<td>-XX:-UseParNewGC -XX:+UseConcMarkSweepGC</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>CMS</td>
<td>N/A</td>
</tr>
<tr>
<td><b>Parallel New</b></td>
<td><b>CMS</b></td>
<td><b>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</b></td>
</tr>
<tr>
<td colspan="2" align="middle"><b>G1</b></td>
<td><b>-XX:+UseG1GC</b></td>
</tr>
</tbody>
</table>
<p>If the above looks too complex, do not worry. In reality it all boils down to just four combinations highlighted in the table above. The rest are either&nbsp;<a href="http://openjdk.java.net/jeps/173">deprecated</a>, not supported or just impractical to apply in real world. So, in the following chapters we cover the working principles of the following combinations:</p>
<ul>
<li>Serial GC for both the Young and Old generations</li>
<li>Parallel GC for both the Young and Old generations</li>
<li>Parallel New for Young + Concurrent Mark and Sweep (CMS) for the Old Generation</li>
<li>G1, which encompasses collection of both Young and Old generations</li>
</ul>

					<h2 id="serial-gc">Serial GC</h2><p>This collection of garbage collectors uses&nbsp;<a href="https://plumbr.io/handbook/garbage-collection-algorithms/removing-unused-objects/copy"><strong>mark-copy</strong></a>&nbsp;for the Young Generation and <a href="https://plumbr.io/handbook/garbage-collection-algorithms/removing-unused-objects/compact"><strong>mark-sweep-compact</strong></a>&nbsp;for the Old Generation. As the name implies – both of these collectors are single-threaded collectors, incapable of parallelizing the task at hand. Both collectors also trigger stop-the-world pauses, stopping all application threads.</p>
<p>This GC algorithm cannot thus take advantage of multiple CPU cores commonly found in modern hardware. Independent of the number of cores available, just one is used by the JVM during garbage collection.</p>
<p>Enabling this collector for both the Young and Old Generation is done via specifying a single parameter in the JVM startup script:</p>
<pre>java -XX:+UseSerialGC com.mypackages.MyExecutableClass</pre>
<p>This option makes sense and is recommended only for the JVM with a couple of hundreds megabytes heap size, running in an environment with a single CPU. For the majority of server-side&nbsp;deployments this is a rare combination. Most server-side deployments are done on platforms with multiple cores, essentially meaning that by choosing Serial GC you are setting artificial limits on the use of system resources. This results in idle resources which otherwise could be used to reduce latency or increase throughput.</p>
<p><span style="line-height: 1.5;">Let us now review how garbage collector logs look like when using Serial GC and what useful information one can obtain from there. For this purpose, we have turned on GC logging on the JVM using the following parameters:</span></p>
<pre>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</pre>
<p>The resulting output is similar to the following:</p>
<pre>2015-05-26T14:45:37.987-0200: 151.126: [GC (Allocation Failure) 151.126: [DefNew: 629119K-&gt;69888K(629120K), 0.0584157 secs] 1619346K-&gt;1273247K(2027264K), 0.0585007 secs] [Times: user=0.06 sys=0.00, real=0.06 secs]
2015-05-26T14:45:59.690-0200: 172.829: [GC (Allocation Failure) 172.829: [DefNew: 629120K-&gt;629120K(629120K), 0.0000372 secs]172.829: [Tenured: 1203359K-&gt;755802K(1398144K), 0.1855567 secs] 1832479K-&gt;755802K(2027264K), [Metaspace: 6741K-&gt;6741K(1056768K)], 0.1856954 secs] [Times: user=0.18 sys=0.00, real=0.18 secs]</pre>
<p>Such&nbsp;short snippet from the GC logs exposes a lot of information about what is taking place inside the JVM. As a matter of fact, in this snippet there were two Garbage Collection events taking place, one of them cleaning the Young Generation and another taking care of the entire heap. Let’s start by analyzing the first collection that is taking place in the Young Generation.</p>
<h3 id="serial-minor-gc">Minor GC</h3><p>Following snippet contains the information about a GC event cleaning the Young Generation:</p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T14:45:37.987-0200<sup>1</sup></span>:<span class="node">151.126<sup>2</sup></span>:[<span class="node">GC<sup>3</sup></span>(<span class="node">Allocation Failure<sup>4</sup></span>) 151.126: [<span class="node">DefNew<sup>5</sup></span>:<span class="node">629119K-&gt;69888K<sup>6</sup></span><span class="node">(629120K)<sup>7</sup></span>, 0.0584157 secs]<span class="node">1619346K-&gt;1273247K<sup>8</sup></span><span class="node">(2027264K)<sup>9</sup></span>,<span class="node">0.0585007 secs<sup>10</sup></span>]<span class="node">[Times: user=0.06 sys=0.00, real=0.06 secs]<sup>11</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T14:45:37.987-0200</span> – Time when the GC event started.</li>
<li class="description"><span class="node">151.126</span> – Time when the GC event started, relative to the JVM startup time. Measured in seconds.</li>
<li class="description"><span class="node">GC</span> – Flag to distinguish between Minor &amp; Full GC. This time it is indicating that this was a Minor GC.</li>
<li class="description"><span class="node">Allocation Failure</span> – Cause of the collection. In this case, the GC is triggered due to a data structure not fitting into any region in the Young Generation.</li>
<li class="description"><span class="node">DefNew</span> – Name of the garbage collector used. This cryptic name stands for the single-threaded mark-copy stop-the-world garbage collector used to clean Young generation.</li>
<li class="description"><span class="node">629119K-&gt;69888K</span> – Usage of the Young Generation before and after collection.</li>
<li class="description"><span class="node">(629120K)</span> – Total size of the Young Generation.</li>
<li class="description"><span class="node">1619346K-&gt;1273247K</span> – Total used heap before and after collection.</li>
<li class="description"><span class="node">(2027264K)</span> – Total available heap.</li>
<li class="description"><span class="node">0.0585007 secs</span> – Duration of the GC event in seconds.</li>
<li class="description"><span class="node">[Times: user=0.06 sys=0.00, real=0.06 secs]</span> – Duration of the GC event, measured in different categories:
<ul>
<li>user – Total CPU time that was consumed by the garbage collector threads during this collection</li>
<li>sys – Time spent in OS calls or waiting for system event</li>
<li>real – Clock time for which your application was stopped. As Serial Garbage Collector always uses just a single thread, real time is thus equal to the sum of user and system times.</li>
</ul>
</li>
</ol>
</div>
<p>From the above snippet we can understand exactly what was happening with the memory consumption inside JVM during the GC event. Before this collection, heap usage totaled at 1,619,346K. Out of this, the Young Generation consumed 629,119K. From this we can calculate the Old Generation usage being equal to 990,227K.</p>
<p>A more important conclusion is hidden in the next batch of numbers indicating that, after the collection, Young Generation usage decreased by 559,231K but total heap usage decreased only by 346,099K. From this we can again derive that 213,132K of objects were promoted from the Young Generation to the Old Generation.</p>
<p>This GC event is also illustrated with the following snapshots showing memory usage right before the GC started and right after it finished:</p>
<p><img class="aligncenter size-full wp-image-4976" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/serial-gc-in-young-generation.png" alt="Serial GC Young Gen Java" width="580" height="131" srcset="https://plumbr.io/app/uploads/2015/06/serial-gc-in-young-generation.png 580w, https://plumbr.io/app/uploads/2015/06/serial-gc-in-young-generation-300x68.png 300w" sizes="(max-width: 580px) 100vw, 580px"></p>
<h3 id="serial-full-gc">Full GC</h3><p>After understanding the first minor GC event, lets look into the second GC event in the logs:</p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T14:45:59.690-0200<sup>1</sup></span>: <span class="node">172.829<sup>2</sup></span>:[GC (Allocation Failure) 172.829:<span class="node"> [DefNew: 629120K-&gt;629120K(629120K), 0.0000372 secs<sup>3</sup></span>]172.829:[<span class="node">Tenured<sup>4</sup></span>: <span class="node">1203359K-&gt;755802K <sup>5</sup></span><span class="node">(1398144K) <sup>6</sup></span>,<span class="node">0.1855567 secs<sup>7</sup></span>] <span class="node">1832479K-&gt;755802K<sup>8</sup></span><span class="node">(2027264K)<sup>9</sup></span>,<span class="node">[Metaspace: 6741K-&gt;6741K(1056768K)]<sup>10</sup></span> <span class="node">[Times: user=0.18 sys=0.00, real=0.18 secs]<sup>11</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T14:45:59.690-0200</span> – Time when the GC event started.</li>
<li class="description"><span class="node">172.829</span> – Time when the GC event started, relative to the JVM startup time. Measured in seconds.</li>
<li class="description"><span class="node">[DefNew: 629120K-&gt;629120K(629120K), 0.0000372 secs</span> – Similar to the previous example, a minor garbage collection in the Young Generation happened during this event due to Allocation Failure. For this collection the same DefNew collector was run as before and it decreased the usage of the Young Generation from 629120K to 0. Notice that JVM reports this incorrectly due to buggy behavior and instead reports the Young Generation as being completely full. This collection took 0.0000372 seconds. </li>
<li class="description"><span class="node">Tenured</span> – Name of the garbage collector used to clean the Old space. The name Tenured indicates a single-threaded stop-the-world mark-sweep-compact garbage collector being used.</li>
<li class="description"><span class="node">1203359K-&gt;755802K </span> – Usage of Old generation before and after the event.</li>
<li class="description"><span class="node">(1398144K) </span> – Total capacity of the Old generation.</li>
<li class="description"><span class="node">0.1855567 secs</span> – Time it took to clean the Old Generation.</li>
<li class="description"><span class="node">1832479K-&gt;755802K</span> – Usage of the whole heap before and after the collection of the Young and Old Generations.</li>
<li class="description"><span class="node">(2027264K)</span> – Total heap available for the JVM.</li>
<li class="description"><span class="node">[Metaspace: 6741K-&gt;6741K(1056768K)]</span> – Similar information about Metaspace collection. As seen, no garbage was collected in Metaspace during the event.</li>
<li class="description"><span class="node">[Times: user=0.18 sys=0.00, real=0.18 secs]</span> – Duration of the GC event, measured in different categories:
<ul>
<li>user – Total CPU time that was consumed by Garbage Collector threads during this collection</li>
<li>sys – Time spent in OS calls or waiting for system event</li>
<li>real – Clock time for which your application was stopped. As Serial Garbage Collector always uses just a single thread, real time is thus equal to the sum of user and system times.</li>
</ul>
</li>
</ol>
</div>
<p>The difference with Minor GC is evident – in addition to the Young Generation, during this GC event the Old Generation and Metaspace were also cleaned. The layout of the memory before and after the event would look like the situation in the following picture:</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/serial-gc-in-old-gen-java.png" alt="Java Old Generation SerialGC" width="580" height="131" class="aligncenter size-full wp-image-5000" srcset="https://plumbr.io/app/uploads/2015/06/serial-gc-in-old-gen-java.png 580w, https://plumbr.io/app/uploads/2015/06/serial-gc-in-old-gen-java-300x68.png 300w" sizes="(max-width: 580px) 100vw, 580px"></p>
<h2 id="parallel-gc">Parallel GC</h2><p>This combination of Garbage Collectors uses&nbsp;<a href="https://plumbr.io/handbook/garbage-collection-algorithms/removing-unused-objects/copy"><strong>mark-copy</strong></a>&nbsp;in the Young Generation and&nbsp;<a href="https://plumbr.io/handbook/garbage-collection-algorithms/removing-unused-objects/compact"><strong>mark-sweep-compact</strong></a>&nbsp;in the Old Generation. Both Young and Old collections trigger stop-the-world events, stopping all application threads to perform garbage collection. Both collectors run marking and copying / compacting phases using multiple threads, hence the name&nbsp;‘Parallel’. Using this approach, collection times&nbsp;can be considerably reduced.</p>
<p>The number of threads used during garbage collection is configurable via the&nbsp;command line parameter&nbsp;<em>-XX:ParallelGCThreads=NNN&nbsp;</em>. The default value is equal to the number of cores in your machine.</p>
<p>Selection of Parallel GC&nbsp;is done via the specification of any of the following combinations of&nbsp;parameters in the JVM startup script:</p>
<pre>java -XX:+UseParallelGC com.mypackages.MyExecutableClass
java -XX:+UseParallelOldGC com.mypackages.MyExecutableClass
java -XX:+UseParallelGC -XX:+UseParallelOldGC com.mypackages.MyExecutableClass</pre>
<p>Parallel Garbage Collector is suitable on multi-core machines in cases where your primary goal is to increase throughput. Higher throughput is achieved due to more efficient usage of system resources:</p>
<ul>
<li>during collection, all cores are cleaning the garbage in parallel, resulting in shorter pauses</li>
<li>between garbage collection cycles neither of the collectors is consuming any resources</li>
</ul>
<p>On the other hand, as all phases of the collection have to happen without any interruptions, these collectors are still susceptible to long pauses during which your application threads are stopped. So if&nbsp;latency is your primary goal, you should check the next combinations of garbage collectors.</p>
<p>Let us now review how garbage collector logs look like when using Parallel GC and what useful information one can obtain from there. For this, let’s look again at the garbage collector logs that expose once more one minor and one major GC pause:</p>
<pre>2015-05-26T14:27:40.915-0200: 116.115: [GC (Allocation Failure) [PSYoungGen: 2694440K-&gt;1305132K(2796544K)] 9556775K-&gt;8438926K(11185152K), 0.2406675 secs] [Times: user=1.77 sys=0.01, real=0.24 secs]
2015-05-26T14:27:41.155-0200: 116.356: [Full GC (Ergonomics) [PSYoungGen: 1305132K-&gt;0K(2796544K)] [ParOldGen: 7133794K-&gt;6597672K(8388608K)] 8438926K-&gt;6597672K(11185152K), [Metaspace: 6745K-&gt;6745K(1056768K)], 0.9158801 secs] [Times: user=4.49 sys=0.64, real=0.92 secs]</pre>
<h3 id="parallel-minor-gc">Minor GC</h3><p>The first of the two events indicates a GC event taking place in the Young Generation:</p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T14:27:40.915-0200<sup>1</sup></span>: <span class="node">116.115<sup>2</sup></span>:[<span class="node">GC<sup>3</sup></span>(<span class="node">Allocation Failure<sup>4</sup></span>)[<span class="node">PSYoungGen<sup>5</sup></span>: <span class="node">2694440K-&gt;1305132K<sup>6</sup></span><span class="node">(2796544K)<sup>7</sup></span>]<span class="node">9556775K-&gt;8438926K<sup>8</sup></span><span class="node">(11185152K)<sup>9</sup></span>, <span class="node">0.2406675 secs<sup>10</sup></span>]<span class="node">[Times: user=1.77 sys=0.01, real=0.24 secs]<sup>11</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T14:27:40.915-0200</span> – Time when the GC event started.</li>
<li class="description"><span class="node">116.115</span> – Time when the GC event started, relative to the JVM startup time. Measured in seconds.</li>
<li class="description"><span class="node">GC</span> – Flag to distinguish between Minor &amp; Full GC. This time it is indicating that this was a Minor GC.</li>
<li class="description"><span class="node">Allocation Failure</span> – Cause of the collection. In this case, the GC is triggered due to a data structure not fitting into any region in the Young Generation.</li>
<li class="description"><span class="node">PSYoungGen</span> – Name of the garbage collector used, representing a parallel mark-copy stop-the-world garbage collector used to clean the Young generation.</li>
<li class="description"><span class="node">2694440K-&gt;1305132K</span> – usage of the Young Generation before and after collection</li>
<li class="description"><span class="node">(2796544K)</span> – Total size of the Young Generation</li>
<li class="description"><span class="node">9556775K-&gt;8438926K</span> – Total heap usage before and after collection</li>
<li class="description"><span class="node">(11185152K)</span> – Total available heap</li>
<li class="description"><span class="node">0.2406675 secs</span> – Duration of the GC event in seconds</li>
<li class="description"><span class="node">[Times: user=1.77 sys=0.01, real=0.24 secs]</span> – Duration of the GC event, measured in different categories:
<ul>
<li>user – Total CPU time that was consumed by Garbage Collector threads during this collection</li>
<li>sys – Time spent in OS calls or waiting for system event</li>
<li>real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount.</li>
</ul>
</li>
</ol>
</div>
<p>So, in short, the total heap consumption before the collection was 9,556,775K. Out of this Young generation was 2,694,440K. This means that used Old generation was 6,862,335K. After the collection young generation usage decreased by 1,389,308K, but total heap usage decreased only by 1,117,849K. This means that 271,459K was promoted from Young generation to Old.</p>
<p><img class="aligncenter size-full wp-image-5002" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/ParallelGC-in-Young-Generation-Java.png" alt="Java ParalleGC" width="580" height="131" srcset="https://plumbr.io/app/uploads/2015/06/ParallelGC-in-Young-Generation-Java.png 580w, https://plumbr.io/app/uploads/2015/06/ParallelGC-in-Young-Generation-Java-300x68.png 300w" sizes="(max-width: 580px) 100vw, 580px"></p>
<h3 id="parallel-full-gc">Full GC</h3><p>After understanding how Parallel GC cleans the Young Generation, we are ready to look at how the whole heap is being cleaned by analyzing the next snippet from the GC logs:</p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T14:27:41.155-0200<sup>1</sup></span>:<span class="node">116.356<sup>2</sup></span>:[<span class="node">Full GC<sup>3</sup></span> (<span class="node">Ergonomics<sup>4</sup></span>)<span class="node">[PSYoungGen: 1305132K-&gt;0K(2796544K)]<sup>5</sup></span>[<span class="node">ParOldGen<sup>6</sup></span>:<span class="node">7133794K-&gt;6597672K <sup>7</sup></span><span class="node">(8388608K)<sup>8</sup></span>] <span class="node">8438926K-&gt;6597672K<sup>9</sup></span><span class="node">(11185152K)<sup>10</sup></span>, <span class="node">[Metaspace: 6745K-&gt;6745K(1056768K)] <sup>11</sup></span>, <span class="node">0.9158801 secs<sup>12</sup></span>, <span class="node">[Times: user=4.49 sys=0.64, real=0.92 secs]<sup>13</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T14:27:41.155-0200</span> – Time when the GC event started</li>
<li class="description"><span class="node">116.356</span> – Time when the GC event started, relative to the JVM startup time. Measured in seconds. In this case we can see the event started right after the previous Minor GC finished.</li>
<li class="description"><span class="node">Full GC</span> – Flag indicating that the event is Full GC event cleaning both the Young and Old generations.</li>
<li class="description"><span class="node">Ergonomics</span> – Reason for the GC taking place. This indicates that the JVM internal ergonomics decided this is the right time to collect some garbage.</li>
<li class="description"><span class="node">[PSYoungGen: 1305132K-&gt;0K(2796544K)]</span> – Similar to previous example, a parallel mark-copy stop-the-world garbage collector named “PSYoungGen” was used to clean the Young Generation. Usage of Young Generation shrank from 1305132K to 0, which is the typical result of a Full GC.</li>
<li class="description"><span class="node">ParOldGen</span> – Type of the collector used to clean the Old Generation. In this case, parallel mark-sweep-compact stop-the-world garbage collector named ParOldGen was used.</li>
<li class="description"><span class="node">7133794K-&gt;6597672K </span> – Usage of the Old Generation before and after the collection</li>
<li class="description"><span class="node">(8388608K)</span> – Total size of the Old Generation</li>
<li class="description"><span class="node">8438926K-&gt;6597672K</span> – Usage of the whole heap before and after the collection.</li>
<li class="description"><span class="node">(11185152K)</span> – Total heap available</li>
<li class="description"><span class="node">[Metaspace: 6745K-&gt;6745K(1056768K)] </span> – Similar information about Metaspace region. As we can see, no garbage was collected in Metaspace during this event.</li>
<li class="description"><span class="node">0.9158801 secs</span> – Duration of the GC event in seconds</li>
<li class="description"><span class="node">[Times: user=4.49 sys=0.64, real=0.92 secs]</span> – Duration of the GC event, measured in different categories:
<ul>
<li>user – Total CPU time that was consumed by Garbage Collector threads during this collection</li>
<li>sys – Time spent in OS calls or waiting for system event</li>
<li>real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount.</li>
</ul>
</li>
</ol>
</div>
<p>Again, the difference with Minor GC is evident – in addition to the Young Generation, during this GC event the Old Generation and Metaspace were also cleaned. The layout of the memory before and after the event would look like the situation in the following picture:</p>
<p><img class="aligncenter size-full wp-image-5003" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/Java-ParallelGC-in-Old-Generation.png" alt="ParallelGC Java" width="580" height="131" srcset="https://plumbr.io/app/uploads/2015/06/Java-ParallelGC-in-Old-Generation.png 580w, https://plumbr.io/app/uploads/2015/06/Java-ParallelGC-in-Old-Generation-300x68.png 300w" sizes="(max-width: 580px) 100vw, 580px"></p>

<h2 id="concurrent-mark-and-sweep">Concurrent Mark and Sweep</h2><p>The official name for&nbsp;this collection of garbage collectors is “Mostly Concurrent Mark and Sweep Garbage Collector”. It uses the parallel stop-the-world&nbsp;<a href="https://plumbr.io/handbook/garbage-collection-algorithms/removing-unused-objects/copy">mark-copy</a>&nbsp;algorithm in the Young Generation and the mostly concurrent&nbsp;<a href="https://plumbr.io/handbook/garbage-collection-algorithms/removing-unused-objects/sweep">mark-sweep</a>&nbsp;algorithm in the Old Generation.</p>
<p>This collector was designed to avoid long pauses while collecting in the Old Generation. It achieves this by two means. Firstly, it does not compact the Old Generation but uses free-lists to manage reclaimed space. Secondly, it does most of the job in the mark-and-sweep phases concurrently with the application. This means that garbage collection is not explicitly stopping the application threads to perform these phases. It should be noted, however, that it still competes for CPU time with the application threads. By default, the number of threads used by this GC algorithm equals to ¼ of the number of physical cores of your machine.</p>
<p>This garbage collector can be chosen by specifying the following option on your command line:</p>
<pre>java -XX:+UseConcMarkSweepGC com.mypackages.MyExecutableClass</pre>
<p>This combination is a good choice on multi-core machines if your primary target is latency. Decreasing the duration of an individual GC pause directly affects the way your application is perceived by end-users, giving them a feel of a more responsive application. As most of the time at least some CPU resources are consumed by the GC and not executing your application’s code, CMS generally often worse throughput than Parallel GC in CPU-bound applications.</p>
<p>As with previous GC algorithms, let us now see how this algorithm is applied in practice by taking a look at the GC logs that once again expose one minor and one major GC pause:</p>
<pre>2015-05-26T16:23:07.219-0200: 64.322: [GC (Allocation Failure) 64.322: [ParNew: 613404K-&gt;68068K(613440K), 0.1020465 secs] 10885349K-&gt;10880154K(12514816K), 0.1021309 secs] [Times: user=0.78 sys=0.01, real=0.11 secs]
2015-05-26T16:23:07.321-0200: 64.425: [GC (CMS Initial Mark) [1 CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2015-05-26T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]
2015-05-26T16:23:07.357-0200: 64.460: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]
2015-05-26T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]
2015-05-26T16:23:07.373-0200: 64.476: [CMS-concurrent-preclean: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2015-05-26T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]
2015-05-26T16:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]
2015-05-26T16:23:08.447-0200: 65.550: [GC (CMS Final Remark) [YG occupancy: 387920 K (613440 K)]65.550: [Rescan (parallel) , 0.0085125 secs]65.559: [weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: [scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
2015-05-26T16:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]
2015-05-26T16:23:08.485-0200: 65.588: [CMS-concurrent-sweep: 0.027/0.027 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]
2015-05-26T16:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]
2015-05-26T16:23:08.497-0200: 65.601: [CMS-concurrent-reset: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</pre>
<h3 id="cms-minor-gc">Minor GC</h3><p>First of the GC events in log denotes a minor GC cleaning the Young space. Let’s analyze how this collector combination behaves in this regard:</p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T16:23:07.219-0200<sup>1</sup></span>: <span class="node">64.322<sup>2</sup></span>:[<span class="node">GC<sup>3</sup></span>(<span class="node">Allocation Failure<sup>4</sup></span>) 64.322: [<span class="node">ParNew<sup>5</sup></span>: <span class="node">613404K-&gt;68068K<sup>6</sup></span><span class="node">(613440K) <sup>7</sup></span>, <span class="node"> 0.1020465 secs<sup>8</sup></span>] <span class="node">10885349K-&gt;10880154K <sup>9</sup></span><span class="node">(12514816K)<sup>10</sup></span>, <span class="node">0.1021309 secs<sup>11</sup></span>]<span class="node">[Times: user=0.78 sys=0.01, real=0.11 secs]<sup>12</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T16:23:07.219-0200</span> – Time when the GC event started.</li>
<li class="description"><span class="node">64.322</span> – Time when the GC event started, relative to the JVM startup time. Measured in seconds.</li>
<li class="description"><span class="node">GC</span> – Flag to distinguish between Minor &amp; Full GC. This time it is indicating that this was a Minor GC.</li>
<li class="description"><span class="node">Allocation Failure</span> – Cause of the collection. In this case, the GC is triggered due to a requested allocation not fitting into any region in Young Generation.</li>
<li class="description"><span class="node">ParNew</span> – Name of the collector used, this time it indicates a parallel mark-copy stop-the-world garbage collector used in the Young Generation, designed to work in conjunction with Concurrent Mark &amp; Sweep garbage collector in the Old Generation.</li>
<li class="description"><span class="node">613404K-&gt;68068K</span> – Usage of the Young Generation before and after collection.</li>
<li class="description"><span class="node">(613440K) </span> – Total size of the Young Generation.</li>
<li class="description"><span class="node"> 0.1020465 secs</span> – Duration for the collection w/o final cleanup.</li>
<li class="description"><span class="node">10885349K-&gt;10880154K </span> – Total used heap before and after collection.</li>
<li class="description"><span class="node">(12514816K)</span> – Total available heap.</li>
<li class="description"><span class="node">0.1021309 secs</span> – The time it took for the garbage collector to mark and copy live objects in the Young Generation. This includes communication overhead with <em>ConcurrentMarkSweep</em> collector, promotion of objects that are old enough to the Old Generation and some final cleanup at the end of the garbage collection cycle.</li>
<li class="description"><span class="node">[Times: user=0.78 sys=0.01, real=0.11 secs]</span> – Duration of the GC event, measured in different categories:
<ul>
<li>user – Total CPU time that was consumed by Garbage Collector threads during this collection</li>
<li>sys – Time spent in OS calls or waiting for system event</li>
<li>real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount.</li>
</ul>
</li>
</ol>
</div>
<p>From the above we can thus see that before the collection the total used heap was 10,885,349K and the used Young Generation share was 613,404K. This means that the Old Generation share was 10,271,945K. After the collection, Young Generation usage decreased by 545,336K but total heap usage decreased only by 5,195K. This means that 540,141K was promoted from the Young Generation to Old.</p>
<p><img class="aligncenter size-full wp-image-5002" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/ParallelGC-in-Young-Generation-Java.png" alt="Java ParalleGC" width="580" height="131" srcset="https://plumbr.io/app/uploads/2015/06/ParallelGC-in-Young-Generation-Java.png 580w, https://plumbr.io/app/uploads/2015/06/ParallelGC-in-Young-Generation-Java-300x68.png 300w" sizes="(max-width: 580px) 100vw, 580px"></p>
<h3 id="cms-full-gc">Full GC</h3><p>Now, just as you are becoming accustomed to reading GC logs already, this chapter will introduce a completely different format for the next garbage collection event in the logs. The lengthy output that follows consists of all the different phases of the mostly concurrent garbage collection in the Old Generation. We will review them one by one but in this case we will cover the log content in phases instead of the entire event log at once for more concise representation. But to recap, the whole event for the CMS collector looks like the following:</p>
<pre>2015-05-26T16:23:07.321-0200: 64.425: [GC (CMS Initial Mark) [1 CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2015-05-26T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]
2015-05-26T16:23:07.357-0200: 64.460: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]
2015-05-26T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]
2015-05-26T16:23:07.373-0200: 64.476: [CMS-concurrent-preclean: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2015-05-26T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]
2015-05-26T16:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]
2015-05-26T16:23:08.447-0200: 65.550: [GC (CMS Final Remark) [YG occupancy: 387920 K (613440 K)]65.550: [Rescan (parallel) , 0.0085125 secs]65.559: [weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: [scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
2015-05-26T16:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]
2015-05-26T16:23:08.485-0200: 65.588: [CMS-concurrent-sweep: 0.027/0.027 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]
2015-05-26T16:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]
2015-05-26T16:23:08.497-0200: 65.601: [CMS-concurrent-reset: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</pre>
<p>Just to bear in mind – in real world situation Minor Garbage Collections of the Young Generation can occur anytime during concurrent collecting the Old Generation. In such case the major collection records seen below will be interleaved with the Minor GC events covered in previous chapter.</p>
<p><b>Phase 1: Initial Mark</b>. This is one of the two stop-the-world events during CMS. The goal of this phase is to mark all the objects in the Old Generation that are either direct GC roots or are referenced from some live object in the Young Generation. The latter is important since the Old Generation is collected separately.</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-06.png" alt="CMS initial mark" width="580" height="184" class="alignnone size-full wp-image-6485" srcset="https://plumbr.io/app/uploads/2015/06/g1-06.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-06-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-06-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-06-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T16:23:07.321-0200: 64.42<sup>1</sup></span>: [GC (<span class="node">CMS Initial Mark<sup>2</sup></span>[1 CMS-initial-mark: <span class="node">10812086K<sup>3</sup></span><span class="node">(11901376K)<sup>4</sup></span>] <span class="node">10887844K<sup>5</sup></span><span class="node">(12514816K)<sup>6</sup></span>, <span class="node">0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<sup>7</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T16:23:07.321-0200: 64.42</span> –&nbsp;Time the GC event started, both clock time and relative to the time from the JVM start. For the following phases the same notion is used throughout the event and is thus skipped for brevity.</li>
<li class="description"><span class="node">CMS Initial Mark</span> – Phase of the collection –&nbsp;“Initial Mark” in this occasion – that is collecting all GC Roots.</li>
<li class="description"><span class="node">10812086K</span> – Currently used Old Generation.</li>
<li class="description"><span class="node">(11901376K)</span> – Total available memory in the Old Generation.</li>
<li class="description"><span class="node">10887844K</span> – Currently used heap</li>
<li class="description"><span class="node">(12514816K)</span> – Total available heap</li>
<li class="description"><span class="node">0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span> – Duration of the phase, measured also in user, system and real time.</li>
</ol>
</div>
<p><b>Phase 2: Concurrent Mark</b>. During this phase the Garbage Collector traverses the Old Generation and marks all live objects, starting from the roots found in the previous phase of “Initial Mark”. The “Concurrent Mark” phase, as its name suggests, runs concurrently with your application and does not stop the application threads. Note that not all the live objects in the Old Generation may be marked, since the application is mutating references during the marking.</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-07.png" alt="CMS concurrent marking" width="580" height="184" class="alignnone size-full wp-image-6486" srcset="https://plumbr.io/app/uploads/2015/06/g1-07.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-07-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-07-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-07-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>In the illustration, a reference pointing away from the “Current object” was removed concurrently with the marking thread.</p>
<div class="code-line-wrap">
<pre class="code-line">2015-05-26T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]
2015-05-26T16:23:07.357-0200: 64.460: [<span class="node">CMS-concurrent-mark<sup>1</sup></span>: <span class="node">035/0.035 secs<sup>2</sup></span>] <span class="node">[Times: user=0.07 sys=0.00, real=0.03 secs]<sup>3</sup></span></pre>
<ol class="code-line-components">
<li class="description"><span class="node">CMS-concurrent-mark</span> – Phase of the collection – “Concurrent Mark” in this occasion – that is traversing the Old Generation and marking all live objects.</li>
<li class="description"><span class="node">035/0.035 secs</span> – Duration of the phase, showing elapsed time and wall clock time correspondingly.</li>
<li class="description"><span class="node">[Times: user=0.07 sys=0.00, real=0.03 secs]</span> – “Times” section is less meaningful for concurrent phases as it is measured from the start of the concurrent marking and includes more than just the work done for the concurrent marking.</li>
</ol>
</div>
<p><b>Phase 3: Concurrent Preclean</b>. This is again a concurrent phase, running in parallel with the application threads, not stopping them. While the previous phase was running concurrently with the application, some references were changed. Whenever that happens, the JVM marks the area of the heap (called “Card”) that contains the mutated object as “dirty” (this is known as <a href="http://psy-lob-saw.blogspot.com.ee/2014/10/the-jvm-write-barrier-card-marking.html">Card Marking</a>).</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-08.png" alt="CMS dirty cards" width="580" height="184" class="alignnone size-full wp-image-6487" srcset="https://plumbr.io/app/uploads/2015/06/g1-08.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-08-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-08-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-08-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>In the pre-cleaning phase, these dirty objects are accounted for, and the objects reachable from them are also marked. The cards are cleaned when this is done.</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-09.png" alt="CMS concurrent preclean" width="580" height="184" class="alignnone size-full wp-image-6488" srcset="https://plumbr.io/app/uploads/2015/06/g1-09.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-09-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-09-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-09-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>Additionally, some necessary housekeeping and preparations for the Final Remark phase are performed.</p>
<div class="code-line-wrap">
<pre class="code-line">2015-05-26T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]
2015-05-26T16:23:07.373-0200: 64.476: [<span class="node">CMS-concurrent-preclean<sup>1</sup></span>: <span class="node">0.016/0.016 secs<sup>2</sup></span>] <span class="node">[Times: user=0.02 sys=0.00, real=0.02 secs]<sup>3</sup></span></pre>
<ol class="code-line-components">
<li class="description"><span class="node">CMS-concurrent-preclean</span> – Phase of the collection – “Concurrent Preclean” in this occasion – accounting for references being changed during previous marking phase.</li>
<li class="description"><span class="node">0.016/0.016 secs</span> – Duration of the phase, showing elapsed time and wall clock time correspondingly.</li>
<li class="description"><span class="node">[Times: user=0.02 sys=0.00, real=0.02 secs]</span> – The “Times” section is less meaningful for concurrent phases as it is measured from the start of the concurrent marking and includes more than just the work done for the concurrent marking.</li>
</ol>
</div>
<p><b>Phase 4: Concurrent Abortable Preclean</b>. Again, a concurrent phase that is not stopping the application’s threads. This one attempts to take as much work off the shoulders of the stop-the-world Final Remark as possible. The exact duration of this phase depends on a number of factors, since it iterates doing the same thing until one of the abortion conditions (such as the number of iterations, amount of useful work done, elapsed wall clock time, etc) is met.</p>
<div class="code-line-wrap">
<pre class="code-line">2015-05-26T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]
2015-05-26T16:23:08.446-0200: 65.550: [<span class="node">CMS-concurrent-abortable-preclean<sup>1</sup></span>: <span class="node">0.167/1.074 secs<sup>2</sup></span>] <span class="node">[Times: user=0.20 sys=0.00, real=1.07 secs]<sup>3</sup></span></pre>
<ol class="code-line-components">
<li class="description"><span class="node">CMS-concurrent-abortable-preclean</span> – Phase of the collection “Concurrent Abortable Preclean” in this occasion</li>
<li class="description"><span class="node">0.167/1.074 secs</span> – Duration of the phase, showing elapsed and wall clock time respectively. It is interesting to note that the user time reported is a lot smaller than clock time. Usually we have seen that real time is less than user time, meaning that some work was done in parallel and so elapsed clock time is less than used CPU time. Here we have a little amount of work – for 0.167 seconds of CPU time, and garbage collector threads were doing a lot of waiting. Essentially, they were trying to stave off for as long as possible before having to do an STW pause. By default, this phase may last for up to 5 seconds.</li>
<li class="description"><span class="node">[Times: user=0.20 sys=0.00, real=1.07 secs]</span> – The “Times” section is less meaningful for concurrent phases, as it is measured from the start of the concurrent marking and includes more than just the work done for the concurrent marking.</li>
</ol>
</div>
<p>This phase may significantly impact the duration of the upcoming stop-the-world pause, and has quite a lot of non-trivial <a href="https://blogs.oracle.com/jonthecollector/entry/did_you_know">configuration options</a> and fail modes.</p>
<p><b>Phase 5: Final Remark</b>. This is the second and last stop-the-world phase during the event. The goal of this stop-the-world phase is to finalize marking all live objects in the Old Generation. Since the previous preclean phases were concurrent, they may have been unable to keep up with the application’s mutating speeds. A stop-the-world pause is required to finish the ordeal.</p>
<p>Usually CMS tries to run final remark phase when Young Generation is as empty as possible in order to eliminate the possibility of several stop-the-world phases happening back-to-back.</p>
<p>This event looks a bit more complex than previous phases:</p>
<div class="code-line-wrap">
<p class="code-line"><span class="node">2015-05-26T16:23:08.447-0200: 65.550<sup>1</sup></span>: [GC (<span class="node">CMS Final Remark<sup>2</sup></span>) [<span class="node">YG occupancy: 387920 K (613440 K)<sup>3</sup></span>]65.550: <span class="node">[Rescan (parallel) , 0.0085125 secs]<sup>4</sup></span>65.559: [<span class="node">weak refs processing, 0.0000243 secs]65.559<sup>5</sup></span>: [<span class="node">class unloading, 0.0013120 secs]65.560<sup>6</sup></span>: [<span class="node">scrub string table, 0.0001759 secs<sup>7</sup></span>][1 CMS-remark: <span class="node">10812086K(11901376K)<sup>8</sup></span>] <span class="node">11200006K(12514816K) <sup>9</sup></span>, <span class="node">0.0110730 secs<sup>10</sup></span>] [<span class="node">[Times: user=0.06 sys=0.00, real=0.01 secs]<sup>11</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">2015-05-26T16:23:08.447-0200: 65.550</span> – Time the GC event started, both clock time and relative to the time from the JVM start.</li>
<li class="description"><span class="node">CMS Final Remark</span> – Phase of the collection – “Final Remark” in this occasion – that is marking all live objects in the Old Generation, including the references that were created/modified during previous concurrent marking phases.</li>
<li class="description"><span class="node">YG occupancy: 387920 K (613440 K)</span> – Current occupancy and capacity of the Young Generation.</li>
<li class="description"><span class="node">[Rescan (parallel) , 0.0085125 secs]</span> – The “Rescan” completes the marking of live objects while the application is stopped. In this case the rescan was done in parallel and took 0.0085125 seconds.</li>
<li class="description"><span class="node">weak refs processing, 0.0000243 secs]65.559</span> – First of the sub-phases that is processing weak references along with the duration and timestamp of the phase.</li>
<li class="description"><span class="node">class unloading, 0.0013120 secs]65.560</span> – Next sub-phase that is unloading the unused classes, with the duration and timestamp of the phase.</li>
<li class="description"><span class="node">scrub string table, 0.0001759 secs</span> – Final sub-phase that is cleaning up symbol and string tables which hold class-level metadata and internalized string respectively. Clock time of the pause is also included.</li>
<li class="description"><span class="node">10812086K(11901376K)</span> – Occupancy and the capacity of the Old Generation after the phase.</li>
<li class="description"><span class="node">11200006K(12514816K) </span> – Usage and the capacity of the total heap after the phase.</li>
<li class="description"><span class="node">0.0110730 secs</span> – Duration of the phase.</li>
<li class="description"><span class="node">[Times: user=0.06 sys=0.00, real=0.01 secs]</span> – Duration of the pause, measured in user, system and real time categories.</li>
</ol>
</div>
<p>After the five marking phases, all live objects in the Old Generation are marked and now garbage collector is going to reclaim all unused objects by sweeping the Old Generation:</p>
<p><b>Phase 6: Concurrent Sweep</b>. Performed concurrently with the application, without the need for the stop-the-world pauses. The purpose of the phase is to remove unused objects and to reclaim the space occupied by them for future use.</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-10.png" alt="CMS concurrent sweep" width="580" height="184" class="alignnone size-full wp-image-6489" srcset="https://plumbr.io/app/uploads/2015/06/g1-10.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-10-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-10-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-10-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<div class="code-line-wrap">
<p class="code-line">2015-05-26T16:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]
2015-05-26T16:23:08.485-0200: 65.588: [<span class="node">CMS-concurrent-sweep<sup>1</sup></span>: <span class="node">0.027/0.027 secs<sup>2</sup></span>] [<span class="node">[Times: user=0.03 sys=0.00, real=0.03 secs] <sup>3</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">CMS-concurrent-sweep</span> – Phase of the collection “Concurrent Sweep” in this occasion, sweeping unmarked and thus unused objects to reclaim space.</li>
<li class="description"><span class="node">0.027/0.027 secs</span> – Duration of the phase, showing elapsed time and wall clock time correspondingly.</li>
<li class="description"><span class="node">[Times: user=0.03 sys=0.00, real=0.03 secs] </span> – “Times” section is less meaningful on concurrent phases, as it is measured from the start of the concurrent marking and includes more than just the work done for the concurrent marking.</li>
</ol>
</div>
<p><b>Phase 7: Concurrent Reset</b>. Concurrently executed phase, resetting inner data structures of the CMS algorithm and preparing them for the next cycle.</p>
<div class="code-line-wrap">
<p class="code-line">2015-05-26T16:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]
2015-05-26T16:23:08.497-0200: 65.601: [<span class="node">CMS-concurrent-reset<sup>1</sup></span>: <span class="node">0.012/0.012 secs<sup>2</sup></span>] [<span class="node">[Times: user=0.01 sys=0.00, real=0.01 secs]<sup>3</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">CMS-concurrent-reset</span> – The phase of the collection – “Concurrent Reset” in this occasion – that is resetting inner data structures of the CMS algorithm and preparing for the next collection.</li>
<li class="description"><span class="node">0.012/0.012 secs</span> – Duration of the the phase, measuring elapsed and wall clock time respectively.</li>
<li class="description"><span class="node">[Times: user=0.01 sys=0.00, real=0.01 secs]</span> – The “Times” section is less meaningful on concurrent phases, as it is measured from the start of the concurrent marking and includes more than just the work done for the concurrent marking.</li>
</ol>
</div>
<p>All in all, the CMS garbage collector does a great job at reducing the pause durations by offloading a great deal of the work to concurrent threads that do not require the application to stop. However, it, too, has some drawbacks, the most notable of them being the Old Generation fragmentation and the lack of predictability in pause durations in some cases, especially on large heaps.</p>
<h2 id="g1">G1 – Garbage First</h2><p>One of the key design goals of G1 was to make the duration and distribution of stop-the-world pauses due to garbage collection predictable and configurable. In fact, Garbage-First is a <em>soft real-time</em> garbage collector, meaning that you can set specific performance goals to it. You can request the stop-the-world pauses to be no longer than x milliseconds within any given y-millisecond long time range, e.g. no more than 5 milliseconds in any given second. Garbage-First GC will do its best to meet this goal with high probability (but not with certainty, that would be <em>hard real-time</em>).</p>
<p>To achieve this, G1 builds upon a number of insights. First, the heap does not have to be split into contiguous Young and Old generation. Instead, the heap is split into a number (typically about 2048) smaller <em>heap regions</em> that can house objects. Each region may be an Eden region, a Survivor region or an Old region. The logical union of all Eden and Survivor regions is the Young Generation, and all the Old regions put together is the Old Generation:</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-011.png" alt="G1 Heap Regions" width="580" height="184" class="alignnone size-full wp-image-6465" srcset="https://plumbr.io/app/uploads/2015/06/g1-011.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-011-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-011-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-011-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>This allows the GC to avoid collecting the entire heap at once, and instead approach the problem <em>incrementally</em>: only a subset of the regions, called the <em>collection set</em> will be considered at a time. All the Young regions are collected during each pause, but some Old regions may be included as well:</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-02.png" alt="G1 Collection Set" width="580" height="184" class="alignnone size-full wp-image-6466" srcset="https://plumbr.io/app/uploads/2015/06/g1-02.png 1160w, https://plumbr.io/app/uploads/2015/06/g1-02-300x95.png 300w, https://plumbr.io/app/uploads/2015/06/g1-02-1024x325.png 1024w, https://plumbr.io/app/uploads/2015/06/g1-02-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>Another novelty of G1 is that during the concurrent phase it estimates the amount of live data that each region contains. This is used in building the collection set: the regions that contain the most garbage are collected first. Hence the name: <em>garbage-first</em> collection.</p>
<p>To run the JVM with the G1 collector enabled, run your application as</p>
<pre>java -XX:+UseG1GC com.mypackages.MyExecutableClass</pre>
<h3 id="evacuation-pause-fully-young">Evacuation Pause: Fully Young</h3><p>In the beginning of the application’s lifecycle, G1 does not have any additional information from the not-yet-executed concurrent phases, so it initially functions in the fully-young mode. When the Young Generation fills up, the application threads are stopped, and the live data inside the Young regions is copied to Survivor regions, or any free regions that thereby become Survivor.</p>
<p>The process of copying these is called Evacuation, and it works in pretty much the same way as the other Young collectors we have seen before. The full logs of evacuation pauses are rather large, so, for simplicity’s sake we will leave out a couple of small bits that are irrelevant in the first fully-young evacuation pause. We will get back to them after the concurrent phases are explained in greater detail. In addition, due to the sheer size of the log record, the parallel phase details and “Other” phase details are extracted to separate sections:</p>
<div class="code-line-wrap">
<p class="code-line nowrap"><span class="node">0.134: [GC pause (G1 Evacuation Pause) (young), 0.0144119 secs]<sup>1</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Parallel Time: 13.9 ms, GC Workers: 8]<sup>2</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">…<sup>3</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Code Root Fixup: 0.0 ms]<sup>4</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Code Root Purge: 0.0 ms]<sup>5</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Clear CT: 0.1 ms]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Other: 0.4 ms]<sup>6</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">…<sup>7</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Eden: 24.0M(24.0M)-&gt;0.0B(13.0M) <sup>8</sup></span><span class="node">Survivors: 0.0B-&gt;3072.0K <sup>9</sup></span><span class="node">Heap: 24.0M(256.0M)-&gt;21.9M(256.0M)]<sup>10</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node"> [Times: user=0.04 sys=0.04, real=0.02 secs] <sup>11</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">0.134: [GC pause (G1 Evacuation Pause) (young), 0.0144119 secs]</span> – G1 pause cleaning only (young) regions. The pause started 134ms after the JVM startup and the duration of the pause was 0.0144 seconds measured in wall clock time.</li>
<li class="description"><span class="node">[Parallel Time: 13.9 ms, GC Workers: 8]</span> – Indicating that for 13.9 ms (real time) the following activities were carried out by 8 threads in parallel</li>
<li class="description"><span class="node">…</span> – Cut for brevity, see the following section below for the details.</li>
<li class="description"><span class="node">[Code Root Fixup: 0.0 ms]</span> – Freeing up the data structures used for managing the parallel activities. Should always be near-zero. This is done sequentially.</li>
<li class="description"><span class="node">[Code Root Purge: 0.0 ms]</span> – Cleaning up more data structures, should also be very fast, but non necessarily almost zero.  This is done sequentially.</li>
<li class="description"><span class="node">[Other: 0.4 ms]</span> – Miscellaneous other activities, many of which are also parallelized</li>
<li class="description"><span class="node">…</span> – See the section below for details</li>
<li class="description"><span class="node">[Eden: 24.0M(24.0M)-&gt;0.0B(13.0M) </span> – Eden usage and capacity before and after the pause</li>
<li class="description"><span class="node">Survivors: 0.0B-&gt;3072.0K </span> – Space used by Survivor regions before and after the pause</li>
<li class="description"><span class="node">Heap: 24.0M(256.0M)-&gt;21.9M(256.0M)]</span> – Total heap usage and capacity before and after the pause.</li>
<li class="description"><span class="node"> [Times: user=0.04 sys=0.04, real=0.02 secs] </span> – Duration of the GC event, measured in different categories:
<ul>
<li>user – Total CPU time that was consumed by Garbage Collector threads during this collection</li>
<li>sys – Time spent in OS calls or waiting for system event</li>
<li>real – Clock time for which your application was stopped. With the parallelizable activities during GC this number is ideally close to (user time + system time) divided by the number of threads used by Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount.</li>
</ul>
</li>
</ol>
</div>
<p>Most of the heavy-lifting is done by multiple dedicated GC worker threads. Their activities are described in the following section of the log:</p>
<div class="code-line-wrap">
<p class="code-line nowrap"><span class="node">[Parallel Time: 13.9 ms, GC Workers: 8]<sup>1</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node"> [GC Worker Start (ms)<sup>2</sup></span><code>: Min: 134.0, Avg: 134.1, Max: 134.1, Diff: 0.1]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Ext Root Scanning (ms)<sup>3</sup></span><code>: Min: 0.1, Avg: 0.2, Max: 0.3, Diff: 0.2, Sum: 1.2]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>[Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Code Root Scanning (ms)<sup>4</sup></span><code>: Min: 0.0, Avg: 0.0, Max: 0.2, Diff: 0.2, Sum: 0.2]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Object Copy (ms)<sup>5</sup></span><code>: Min: 10.8, Avg: 12.1, Max: 12.6, Diff: 1.9, Sum: 96.5]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Termination (ms)<sup>6</sup></span><code>: Min: 0.8, Avg: 1.5, Max: 2.8, Diff: 1.9, Sum: 12.2]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Termination Attempts<sup>7</sup></span><code>: Min: 173, Avg: 293.2, Max: 362, Diff: 189, Sum: 2346]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[GC Worker Other (ms)<sup>8</sup></span><code>: Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">GC Worker Total (ms)<sup>9</sup></span><code>: Min: 13.7, Avg: 13.8, Max: 13.8, Diff: 0.1, Sum: 110.2]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[GC Worker End (ms)<sup>10</sup></span>: Min: 147.8, Avg: 147.8, Max: 147.8, Diff: 0.0]
</p><ol class="code-line-components">
<li class="description"><span class="node">[Parallel Time: 13.9 ms, GC Workers: 8]</span> – Indicating that for 13.9 ms (clock time) the following activities were carried out by 8 threads in parallel</li>
<li class="description"><span class="node"> [GC Worker Start (ms)</span> – The moment in time at which the workers started their activity, matching the timestamp at the beginning of the pause. If Min and Max differ a lot, then it may be an indication that too many threads are used or other processes on the machine are stealing CPU time from the garbage collection process inside the JVM</li>
<li class="description"><span class="node">[Ext Root Scanning (ms)</span> – How long it took to scan the external (non-heap) roots such as classloaders, JNI references, JVM system roots, etc. Shows elapsed time, “Sum” is CPU time</li>
<li class="description"><span class="node">[Code Root Scanning (ms)</span> – How long it took to scan the roots that came from the actual code: local vars, etc.</li>
<li class="description"><span class="node">[Object Copy (ms)</span> – How long it took to copy the live objects away from the collected regions.</li>
<li class="description"><span class="node">[Termination (ms)</span> – How long it took for the worker threads to ensure that they can safely stop and that there’s no more work to be done, and then actually terminate</li>
<li class="description"><span class="node">[Termination Attempts</span> – How many attempts worker threads took to try and terminate. An attempt is failed if the worker discovers that there’s in fact more work to be done, and it’s too early to terminate.</li>
<li class="description"><span class="node">[GC Worker Other (ms)</span> – Other miscellaneous small activities that do not deserve a separate section in the logs.</li>
<li class="description"><span class="node">GC Worker Total (ms)</span> – How long the worker threads have worked for in total</li>
<li class="description"><span class="node">[GC Worker End (ms)</span> – The timestamp at which the workers have finished their jobs. Normally they should be roughly equal, otherwise it may be an indication of too many threads hanging around or a noisy neighbor</li>
</ol>
</div>
<p>Additionally, there are some miscellaneous activities that are performed during the Evacuation pause. We will only cover a part of them in this section. The rest will be covered later.</p>
<div class="code-line-wrap">
<p class="code-line nowrap"><span class="node">[Other: 0.4 ms]<sup>1</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Choose CSet: 0.0 ms]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Ref Proc: 0.2 ms]<sup>2</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Ref Enq: 0.0 ms]<sup>3</sup></span><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Redirty Cards: 0.1 ms]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Humongous Register: 0.0 ms]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<code>[Humongous Reclaim: 0.0 ms]</code><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="node">[Free CSet: 0.0 ms]<sup>4</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">[Other: 0.4 ms]</span> – Miscellaneous other activities, many of which are also parallelized</li>
<li class="description"><span class="node">[Ref Proc: 0.2 ms]</span> – The time it took to process non-strong references: clear them or determine that no clearing is needed.</li>
<li class="description"><span class="node">[Ref Enq: 0.0 ms]</span> – The time it took to enqueue the remaining non-strong references to the appropriate ReferenceQueue</li>
<li class="description"><span class="node">[Free CSet: 0.0 ms]</span> – The time it takes to return the freed regions in the collection set so that they are available for new allocations.</li>
</ol>
</div>
<h3 id="concurrent-marking">Concurrent Marking</h3><p>The G1 collector builds up on many concepts of CMS from the previous section, so it is a good idea to make sure that you have a sufficient understanding of it before proceeding. Even though it differs in a number of ways, the goals of the Concurrent Marking are very similar. &nbsp;G1 Concurrent Marking uses the Snapshot-At-The-Beginning approach that marks all the objects that were live at the beginning of the marking cycle, even if they have turned into garbage meanwhile. The information on which objects are live allows to build up the liveness stats for each region so that the collection set could be efficiently chosen afterwards.</p>
<p>This information is then used to perform garbage collection in the Old regions. It can happen fully concurrently, if the marking determines that a region contains only garbage, or during a stop-the-world evacuation pause for Old regions that contain both garbage and live objects.</p>
<p>Concurrent Marking starts when the overall occupancy of the heap is large enough. By default, it is 45%, but this can be changed by the <strong>InitiatingHeapOccupancyPercent</strong> JVM option. Like in CMS, Concurrent Marking in G1 consists of a number of phases, some of them fully concurrent, and some of them requiring the application threads to be stopped.</p>
<p><strong>Phase 1: Initial Mark</strong>. This phase marks all the objects directly reachable from the GC roots. In CMS, it required a separate stop-the world pause, but in G1 it is typically piggy-backed on an Evacuation Pause, so its overhead is minimal. You can notice this pause in GC logs by the “(initial-mark)” addition in the first line of an Evacuation Pause:</p>
<pre>1.631: [GC pause (G1 Evacuation Pause) (young) <strong>(initial-mark)</strong>, 0.0062656 secs]</pre>
<p><strong>Phase 2: Root Region Scan. </strong>This phase marks all the live objects reachable from the so-called root regions, i.e. the ones that are not empty and that we might end up having to collect in the middle of the marking cycle. Since moving stuff around in the middle of concurrent marking will cause trouble, this phase has to complete before the next evacuation pause starts. If it has to start earlier, it will request an early abort of root region scan, and then wait for it to finish. In the current implementation, the root regions are the survivor regions: they are the bits of Young Generation that will definitely be collected in the next Evacuation Pause.</p>
<pre>1.362: [GC concurrent-root-region-scan-start]
1.364: [GC concurrent-root-region-scan-end, 0.0028513 secs]</pre>
<p><strong>Phase 3. Concurrent Mark. </strong>This phase is very much similar to that of CMS: it simply walks the object graph and marks the visited objects in a special bitmap. To ensure that the semantics of snapshot-at-the beginning are met, G1 GC requires that all the concurrent updates to the object graph made by the application threads leave the previous reference known for marking purposes. </p>
<p>This is achieved by the use of the Pre-Write barriers (not to be confused with Post-Write barriers discussed later and memory barriers that relate to multithreaded programming). Their function is to, whenever you write to a field while G1 Concurrent Marking is active, store the previous referee in the so-called log buffers, to be processed by the concurrent marking threads.</p>
<pre>1.364: [GC concurrent-mark-start]
1.645: [GC concurrent-mark-end, 0.2803470 secs]</pre>
<p><strong>Phase 4. Remark.</strong> This is a stop-the-world pause that, like previously seen in CMS, completes the marking process. For G1, it briefly stops the application threads to stop the inflow of the concurrent update logs and processes the little amount of them that is left over, and marks whatever still-unmarked objects that were live when the concurrent marking cycle was initiated. This phase also performs some additional cleaning, e.g. reference processing (see the Evacuation Pause log) or class unloading.</p>
<pre>1.645: [GC remark 1.645: [Finalize Marking, 0.0009461 secs] 1.646: [GC ref-proc, 0.0000417 secs] 1.646: [Unloading, 0.0011301 secs], 0.0074056 secs]
[Times: user=0.01 sys=0.00, real=0.01 secs]</pre>
<p><strong>Phase 5. Cleanup.</strong> This final phase prepares the ground for the upcoming evacuation phase, counting all the live objects in the heap regions, and sorting these regions by expected GC efficiency. It also performs all the house-keeping activities required to maintain the internal state for the next iteration of concurrent marking. </p>
<p>Last but not least, the regions that contain no live objects at all are reclaimed in this phase. Some parts of this phase are concurrent, such as the empty region reclamation and most of the liveness calculation, but it also requires a short stop-the-world pause to finalize the picture while the application threads are not interfering. The logs for such stop-the-world pauses would be similar to:</p>
<pre>1.652: [GC cleanup 1213M-&gt;1213M(1885M), 0.0030492 secs]
[Times: user=0.01 sys=0.00, real=0.00 secs]</pre>
<p>In case when some heap regions that only contain garbage were discovered, the pause format can look a bit different, similar to:</p>
<pre>1.872: [GC cleanup 1357M-&gt;173M(1996M), 0.0015664 secs]
[Times: user=0.01 sys=0.00, real=0.01 secs]
1.874: [GC concurrent-cleanup-start]
1.876: [GC concurrent-cleanup-end, 0.0014846 secs]</pre>
<h3 id="evacuation-pause-mixed">Evacuation Pause: Mixed</h3><p>It’s a pleasant case when concurrent cleanup can free up entire regions in Old Generation, but it may not always be the case. After Concurrent Marking has successfully completed, G1 will schedule a mixed collection that will not only get the garbage away from the young regions, but also throw in a bunch of Old regions to the collection set.</p>
<p>A mixed Evacuation pause does not always immediately follow the end of the concurrent marking phase. There is a number of rules and heuristics that affect this. For instance, if it was possible to free up a large portion of the Old regions concurrently, then there is no need to do it.</p>
<p>There may, therefore, easily be a number of fully-young evacuation pauses between the end of concurrent marking and a mixed evacuation pause.</p>
<p>The exact number of Old regions to be added to the collection set, and the order in which they are added, is also selected based on a number of rules. These include the soft real-time performance goals specified for the application, the liveness and gc efficiency data collected during concurrent marking, and a number of configurable JVM options. The process of a mixed collection is largely the same as we have already reviewed earlier for fully-young gc, but this time we will also cover the subject of <em>remembered sets</em>.</p>
<p>Remembered sets are what allows the independent collection of different heap regions. For instance, when collecting region A,B and C, we have to know whether or not there are references to them from regions D and E to determine their liveness. But traversing the whole heap graph would take quite a while and ruin the whole point of incremental collection, therefore an optimization is employed. Much like we have the Card Table for independently collecting Young regions in other GC algorithms, we have Remembered Sets in G1.</p>
<p>As shown in the illustration below, each region has a remembered set that lists the references pointing to this region from the outside. These references will then be regarded as additional GC roots. Note that objects in Old regions that were determined to be garbage during concurrent marking will be ignored even if there are outside references to them: the referents are also garbage in that case.</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-03.png" alt="Mixed Evacuation Pause: beginning" width="580" height="184" class="alignnone size-full wp-image-6475" srcset="https://plumbr.io/app/uploads/2016/01/g1-03.png 1160w, https://plumbr.io/app/uploads/2016/01/g1-03-300x95.png 300w, https://plumbr.io/app/uploads/2016/01/g1-03-1024x325.png 1024w, https://plumbr.io/app/uploads/2016/01/g1-03-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>What happens next is the same as what other collectors do: multiple parallel GC threads figure out what objects are live and which ones are garbage:</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-04.png" alt="Mixed Evacuation Pause: determining live objects" width="580" height="184" class="alignnone size-full wp-image-6476" srcset="https://plumbr.io/app/uploads/2016/01/g1-04.png 1160w, https://plumbr.io/app/uploads/2016/01/g1-04-300x95.png 300w, https://plumbr.io/app/uploads/2016/01/g1-04-1024x325.png 1024w, https://plumbr.io/app/uploads/2016/01/g1-04-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>And, finally, the live objects are moved to survivor regions, creating new if necessary. The now empty regions are freed and can be used for storing objects in again.</p>
<p><img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/g1-05-v2.png" alt="g1-05-v2" width="580" height="184" class="alignnone size-full wp-image-6480" srcset="https://plumbr.io/app/uploads/2016/01/g1-05-v2.png 1160w, https://plumbr.io/app/uploads/2016/01/g1-05-v2-300x95.png 300w, https://plumbr.io/app/uploads/2016/01/g1-05-v2-1024x325.png 1024w, https://plumbr.io/app/uploads/2016/01/g1-05-v2-591x187.png 591w" sizes="(max-width: 580px) 100vw, 580px"></p>
<p>To maintain the remembered sets, during the runtime of the application, a Post-Write Barrier is issued whenever a write to a field is performed. If the resulting reference is cross-region, i.e. pointing from one region to another, a corresponding entry will appear in the Remembered Set of the target region. To reduce the overhead that the Write Barrier introduces, the process of putting the cards into the Remembered Set is asynchronous and features quite a number of optimizations. But basically it boils down to the Write Barrier putting the dirty card information into a local buffer, and a specialized GC thread picking it up and propagating the information to the remembered set of the referred region.</p>
<p>In the mixed mode, the logs publish certain new interesting aspects when compared to the fully young mode:</p>
<div class="code-line-wrap">
<p class="code-line nowrap"><span class="node">[Update RS (ms)<sup>1</sup></span><code>: Min: 0.7, Avg: 0.8, Max: 0.9, Diff: 0.2, Sum: 6.1]</code><br><span class="node">[Processed Buffers<sup>2</sup></span><code>: Min: 0, Avg: 2.2, Max: 5, Diff: 5, Sum: 18]</code><br><span class="node">[Scan RS (ms)<sup>3</sup></span><code>: Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.8]</code><br><span class="node">[Clear CT: 0.2 ms]<sup>4</sup></span><br><span class="node">[Redirty Cards: 0.1 ms]<sup>5</sup></span></p>
<ol class="code-line-components">
<li class="description"><span class="node">[Update RS (ms)</span> – Since the Remembered Sets are processed concurrently, we have to make sure that the still-buffered cards are processed before the actual collection begins. If this number is high, then the concurrent GC threads are unable to handle the load. It may be, e.g., because of an overwhelming number of incoming field modifications, or insufficient CPU resources.</li>
<li class="description"><span class="node">[Processed Buffers</span> – How many local buffers each worker thread has processed.</li>
<li class="description"><span class="node">[Scan RS (ms)</span> – How long it took to scan the references coming in from remembered sets.</li>
<li class="description"><span class="node">[Clear CT: 0.2 ms]</span> – Time to clean the cards in the card table. Cleaning simply removes the “dirty” status that was put there to signify that a field was updated, to be used for Remembered Sets.</li>
<li class="description"><span class="node">[Redirty Cards: 0.1 ms]</span> – The time it takes to mark the appropriate locations in the card table as dirty. Appropriate locations are defined by the mutations to the heap that GC does itself, e.g. while enqueuing references.</li>
</ol>
</div>
<h3 id="summary">Summary</h3><p>This should give one a sufficient basic understanding of how G1 functions. There are, of course, still quite some implementation details that we have left out for brevity, like dealing with <a href="https://plumbr.io/handbook/gc-tuning-in-practice#humongous-allocations">humongous objects</a>. All things considered, G1 is the most technologically advanced production-ready collector available in HotSpot. On top of that, it is being relentlessly improved by the HotSpot Engineers, with new optimizations or features coming in with newer java versions.</p>
<p>As we have seen, G1 addressed a wide range of problems that CMS has, starting from pause predictability and ending with heap fragmentation. Given an application not constrained by CPU utilization, but very sensitive to the latency of individual operations, G1 is very likely to be the best available choice for HotSpot users, especially when running the latest versions of Java. However, these latency improvements do not come for free: throughput overhead of G1 is larger thanks to the additional write barriers and more active background threads. So, if the application is throughput-bound or is consuming 100% of CPU, and does not care as much about individual pause durations, then CMS or even Parallel may be better choices.</p>
<p>The only viable way to select the right GC algorithm and settings is through trial and errors, but we do give the general guidelines in the next chapter.</p>
<p>Note that G1 will probably be the default GC for Java 9: <a href="http://openjdk.java.net/jeps/248">http://openjdk.java.net/jeps/248</a></p>
<p>&nbsp;</p>
<h2 id="shenandoah">Shenandoah</h2><p>We have outlined all of the production-ready algorithms in HotSpot that you can just take and use right away. There is another one in the making, a so-called Ultra-Low-Pause-Time Garbage Collector. It is aimed for large multi-core machines with large heaps, the goal is to manage heaps of 100GB and larger with pauses of 10ms or shorter. This is traded off against throughput: the implementers are aiming at a no more than 10% of a performance penalty for applications with no GC pauses.</p>
<p>We are not going to go into the implementation details before the new algorithm is released as production-ready, but it also builds upon many of the ideas already covered in earlier chapters, such as concurrent marking and incremental collecting. It does a lot of things differently, however. It does not split the heap into multiple generations, instead having a single space only. That’s right, Shenandoah is not a generational garbage collector. This allows it to get rid of card tables and remembered sets. It also uses forwarding pointers and a Brooks style read barrier to allow for concurrent copying of live objects, thus reducing the number and duration of pauses.</p>
<p>A lot of more detailed and up-to-date information about Shenandoah is available on the Internet, for instance in this blog: <a href="https://rkennke.wordpress.com/">https://rkennke.wordpress.com/</a></p>

				            </div>
        </div>
    </div>
</div>

	<div id="footer">
		<div class="wrap">
			<div id="menu-footer" class="row clear fat-footer"><div class="col-2"><ul><li class="title"><strong>Products &amp; Services</strong></li><li><a href="https://plumbr.io/application-monitoring">Application Monitoring</a></li><li><a href="https://plumbr.io/product/rum">Real-User Monitoring</a></li></ul></div><div class="col-2"><ul><li class="title"><strong>Company</strong></li><li><a href="https://plumbr.io/about-us">About us</a></li><li><a href="https://plumbr.io/join-us">Join us</a></li></ul></div><div class="col-2"><ul><li class="title"><strong>Support</strong></li><li><a href="https://plumbr.io/support/manual">Manual</a></li><li><a href="https://plumbr.io/support/what-is-plumbr-2">FAQ</a></li></ul></div><div class="col-2"><ul><li class="title"><strong>Resources</strong></li><li><a href="https://plumbr.io/blog">Blog</a></li><li><a href="https://plumbr.io/java-garbage-collection-handbook">Garbage Collection Handbook</a></li><li><a href="https://plumbr.io/outofmemoryerror">Memory Leak Handbook</a></li></ul></div><div class="col-2"><ul><li class="title"><strong>Pricing</strong></li><li><a href="https://plumbr.io/pricing">Pricing</a></li></ul></div><div class="col-2"><ul><li class="title"><strong>Integrations</strong></li><li><a href="https://plumbr.io/support/manual#browser-agent-api">Browser Agent API</a></li><li><a href="https://plumbr.io/support/manual#agent-api">Java Agent API</a></li><li><a href="https://app.plumbr.io/docs">Server API</a></li><li><a href="https://plumbr.io/integrations/nagios">Nagios</a></li><li><a href="https://plumbr.io/integrations/prometheus">Prometheus</a></li><li><a href="https://plumbr.io/integrations/zabbix">Zabbix</a></li></ul></div></div><div class="textwidget custom-html-widget"><ul class="social">
	<li><a href="mailto:support@plumbr.io"><i class="icon icon-mail-alt"></i></a></li>
	<li><a target="_blank" href="https://twitter.com/JavaPlumbr" rel="noopener noreferrer"><i class="icon icon-twitter-squared"></i></a></li>
	<li><a target="_blank" href="https://www.linkedin.com/company/plumbr" rel="noopener noreferrer"><i class="icon icon-linkedin-squared"></i></a></li>
	<li>
<a style="display: flex;" href="https://www.capterra.com/reviews/151215/Plumbr?utm_source=vendor&amp;utm_medium=badge&amp;utm_campaign=capterra_reviews_badge">  <img alt="capterra" style="height: 23px;
width: 45px;" border="0" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/67206f388f45e0bc89ee313994c73a7d.png"></a>
</li>
</ul>
<p id="copyright">© Copyright Plumbr. All Rights Reserved. </p></div>		</div>
	</div>
	
<div id="modal-wrap">
	
	        <div class="modal full alt" id="intro-sample-1">
            <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" class="close"><i class="icon icon-cancel"></i></a>
            <img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/intro-sample-1.png" alt="">
        </div>

        <div class="modal full alt" id="intro-sample-2">
            <a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" class="close"><i class="icon icon-cancel"></i></a>
            <img src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/intro-sample-2.png" alt="">
        </div>
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	

	
	<div class="modal login" id="modal-login">
	<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" id="modal-login-close" class="close"><i class="icon icon-cancel"></i></a>
	<h2>Log In</h2>
	<form id="modal-login-form">
		<dl class="form">
			<dt><label for="login-mail">Your e-mail</label></dt>
			<dd>
				<input name="userName" type="email" id="login-mail" class="txt" maxlength="255" autofocus="autofocus" tabindex="1">
			</dd>
			<dt><label for="login-password">Password</label></dt>
			<dd>
				<input name="password" type="password" id="login-password" class="txt" maxlength="255" tabindex="2">
				<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" id="forgot-password" data-modal="modal-new-password" tabindex="5">Forgot your password?</a>
			</dd>
			<dd><input name="isFromComment" type="hidden" id="login-comment" class="txt" value="false"></dd>
		</dl>
		<p class="form-action"><input id="modal-login-submit" type="submit" class="btn big" value="LOG IN" tabindex="3"></p>
	</form>
</div>
	<div class="modal login" id="modal-new-password">
	<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" class="close"><i class="icon icon-cancel"></i></a>
	<h2>Reset password</h2>
	<p>You will receive a link to create a new password via email.</p>

	<div class="msg-icon hidden" id="reset-success">
		<i class="icon icon-ok"></i>

		<div class="aligner">
			<p>Instructions on how to change your password have been sent to your e-mail.</p>
		</div>
	</div>

	<form>
		<dl class="form">
			<dt><label for="new-mail">Email</label></dt>
			<dd><input name="email" type="email" id="new-mail" class="txt"></dd>
		</dl>
		<p class="form-action"><input type="submit" class="btn big" value="Get new password"></p>
	</form>
</div>
	<div class="modal signup" id="modal-register">
	<a href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" class="close"><i class="icon icon-cancel"></i></a>
	<div class="register">
		<h2>Notification</h2>
		<p class="info">Plumbr has been acquired by Splunk and no longer offers trial access to its product.
		Read more <a href="https://www.splunk.com/en_us/blog/conf-splunklive/splunk-extends-best-in-class-observability-suite.html">here</a></p>
	</div>
</div>

	<div class="modal video" id="modal-video">
		<a id="close-video" href="https://plumbr.io/handbook/garbage-collection-algorithms-implementations#" class="close"><i class="icon icon-cancel"></i></a>
		<div class="flex-video">
			<div id="video01"></div>
		</div>
	</div>

	
	
	





</div>
	
<div id="cookie-consent" class="cookies" style="display: none;">
    <div id="overview">
        <p>This site uses cookies in order to provide a better user experience to you.</p>

        <div class="buttons">
            <button id="acceptAll" class="cbtn wide">Accept all cookies</button>
            <button id="cookieSettings" class="cbtn wide deny">Cookie settings</button>
        </div>
    </div>

    <div id="settings" class="hidden">
        <div>
            <label class="cookie-label disabled">
                Required cookies
                <input checked="true" type="checkbox" disabled="">
                <span class="checkmark"></span>
            </label>

            <p class="desc">These cookies are required to enable core site functionality.</p>
        </div>

        <div class="cookie-type">
            <label class="cookie-label">
                Statistics &amp; analytics cookies
                <input id="analytics-checkbox" type="checkbox">
                <span class="checkmark"></span>
            </label>

            <p class="desc">These cookies give us information about how you use our website and allow us to improve
                the user experience.</p>
        </div>

        <p>To learn more about our cookie usage click <a href="https://plumbr.io/support/plumbr-cookies" target="_blank">here</a>.</p>

        <div style="margin-top: 10px;">
            <button id="cookieCancel" class="cbtn">Cancel</button>
            <button id="cookieSave" class="cbtn">Save</button>
        </div>
    </div>
</div>
	
<script type="text/javascript">
/* <![CDATA[ */
var leadin_wordpress = {"userRole":"visitor","pageType":"post","leadinPluginVersion":"7.48.24"};
/* ]]> */
</script>
<script async="" defer="" id="hs-script-loader" type="text/javascript" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/5894543.js(2).download"></script>
<script type="text/javascript">
/* <![CDATA[ */
var param = {"portalUrl":"https:\/\/app.plumbr.io"};
/* ]]> */
</script>



<script type="text/javascript">
/* <![CDATA[ */
var local = {"isSupportIndex":"","isSupportType":"","isEmailLandingPage":"","isSearch":"","ajaxurl":"https:\/\/plumbr.io\/wp\/wp-admin\/admin-ajax.php"};
/* ]]> */
</script>





<script type="text/javascript" defer="" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/autoptimize_80f1fdb2d70c854f88929cb5e1e65e79.js.download"></script>

<iframe owner="archetype" title="archetype" style="display: none; visibility: hidden;" src="./GC Algorithms_ Implementations _ Plumbr – User Experience &amp; Application Performance Monitoring_files/saved_resource.html"></iframe></body></html>